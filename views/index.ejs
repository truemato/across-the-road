<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>細道</title>
  <script src="https://cdn.socket.io/4.5.1/socket.io.min.js"></script>
  <!-- 環境変数から Google Maps API Key を挿入 -->
    <script
    src="https://maps.googleapis.com/maps/api/js?key=<%= googleMapsApiKey %>&callback=initMap&v=weekly&libraries=marker"
    async defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

  <style>

    body {
      margin: 0;
      padding: 0;
      font-family: Arial, sans-serif;
      height: 100vh;
      overflow: hidden;
    }
    #port-selector {
            position: fixed;
            right: 10px;
            bottom: 10px;
            background: white;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.1);
        }
        select, button {
            margin-top: 5px;
            width: 100%;
        }
        #status {
            margin-top: 10px;
            font-size: 14px;
        }
    #threejs-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 3; /* 地図より背面に配置 */
      pointer-events: none; /* Three.jsが地図操作を邪魔しない */
    }
    #street-view {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100vh;
      z-index: 1;
    }
    #map {
      position: absolute;
      left: 20px;
      bottom: 20px;
      width: 30%;
      height: 30vh;
      border-radius: 15px;
      background: rgba(255, 255, 255, 0.9);
      z-index: 2;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    #current-log {
	position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.9);
      z-index: 2;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    #input-log {
      position: absolute;
      right: 20px;
      top: 20px;
      width: 20%;
      max-height: 80vh;
      overflow-y: auto;
      border-radius: 8px;
      padding: 15px;
      background: rgba(200, 200, 200, 0.9);
      z-index: 2;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
    }
    a {
      color: gray;
      text-decoration: none;
      border-bottom: 1px dotted gray;
    }
    a:visited {
      color: gray;
      border-bottom: 1px dotted gray;
    }
    a:hover {
      color: gray;
      border-bottom: 1px dotted gray;
    }
    a:active {
      color: gray;
      border-bottom: 1px dotted gray;
    }
  </style>
</head>
	<body>
  <div id="street-view"></div>
  <div id="map"></div>
  <div id="current-log">Loading...</div>
  <div id="sensor-log" style="position: absolute; top: 20px; right: 20px; background: white; padding: 10px; border-radius: 8px; box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);">
    Loading...
  </div>
  <div id="input-log"></div>
    <div id="threejs-container"></div>

  <script>
    // Three.js 初期化
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });

    const container = document.getElementById('threejs-container');
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0);
    container.appendChild(renderer.domElement);

    const light = new THREE.PointLight(0xffffff, 1);
    light.position.set(10, 10, 10);
    scene.add(light);

    const redMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
    const whiteMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const group = new THREE.Group();

    for (let i = 0; i < 4; i++) {
      const geometry = new THREE.CylinderGeometry(5, 5, 2, 32, 1, false, i * Math.PI / 2, Math.PI / 2);
      const material = i % 2 === 0 ? redMaterial : whiteMaterial;
      const section = new THREE.Mesh(geometry, material);
      group.add(section);
    }
    group.rotation.z = Math.PI / 2;

	group.scale.set(1.5, 1.5, 1.5);
    scene.add(group);

	// カメラ位置と向きを調整 (左後ろから見下ろすイメージ)
	camera.position.set(10, 15, 35);
	camera.lookAt(group.position);

    let currentValue = 0;
    let currentLat = 34.9862105;
    let currentLng = 135.7662586;
    let updateCount = 0;
    let totalDistance = 0;
    let map, marker, streetView;

    async function initPosition() {
      try {
        const response = await fetch("http://localhost:4000/api/lastplace/latest");
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const latestPlace = await response.json();
        currentLat = latestPlace.lat;
        currentLng = latestPlace.lng;
        console.log("最新の位置情報:", currentLat, currentLng);
		} catch (error) {
        console.error("最新位置の取得に失敗しました:", error);
        // 失敗した場合はフェールバックの初期値がそのまま使用されます
      }
    }
    function animate() {
      requestAnimationFrame(animate);
      group.rotation.x -= currentValue * 3.3; // valueの値に基づいて回転
      renderer.render(scene, camera);
    }
    animate();

    async function initMap() {
      // マップの初期化
      map = new google.maps.Map(document.getElementById("map"), {
        center: { lat: currentLat, lng: currentLng },
        zoom: 15,
        mapId: "d083e2f5874ba61c",  // mapID は mapId に変更される可能性もあるので注意
      });
      // AdvancedMarkerElement の初期化
      marker = new google.maps.marker.AdvancedMarkerElement({
        position: { lat: currentLat, lng: currentLng },
        map: map,
        // 必要に応じて title や content などのプロパティを追加できます
      });
      // StreetView の初期化
      streetView = new google.maps.StreetViewPanorama(
        document.getElementById("street-view"),
        {
          position: { lat: currentLat, lng: currentLng },
          pov: { heading: 0, pitch: 0 },
          zoom: 1,
        }
      );
      map.setStreetView(streetView);
    }
    function getNearestPanorama(location, radius = 100) {
      return new Promise((resolve, reject) => {
        const svService = new google.maps.StreetViewService();
        svService.getPanorama({ location, radius }, (data, status) => {
          if (
            status === google.maps.StreetViewStatus.OK &&
            data &&
            data.location
          ) {
            resolve(data.location.latLng);
          } else {
            reject(
              `No panorama found near ${location.lat}, ${location.lng} (status: ${status})`
            );
          }
        });
      });
    }
        // updatePegman: computedPos を基に Roads API でスナップし、さらに有効なパノラマがあれば更新
    // ============================
    async function updatePegman(computedPos) {
      try {
        const apiKey = "<%= googleMapsApiKey %>";
        const roadsUrl = `https://roads.googleapis.com/v1/snapToRoads?path=${computedPos.lat},${computedPos.lng}&key=${apiKey}`;
        const response = await fetch(roadsUrl);
        if (!response.ok) {
          throw new Error(`Roads API error: ${response.status}`);
        }
        const roadsData = await response.json();
        let snappedPos;
        if (roadsData.snappedPoints && roadsData.snappedPoints.length > 0) {
          const loc = roadsData.snappedPoints[0].location;
          snappedPos = { lat: loc.latitude, lng: loc.longitude };
        } else {
          snappedPos = computedPos;
        }
        // 取得した位置付近に有効なパノラマがあるか確認
        try {
          const nearestPanorama = await getNearestPanorama(
            new google.maps.LatLng(snappedPos.lat, snappedPos.lng),
            100
          );
          pegmanPosition = {
            lat: nearestPanorama.lat(),
            lng: nearestPanorama.lng(),
          };
          console.log("Pegman updated from panorama:", pegmanPosition);
        } catch (panoramaErr) {
          console.warn(panoramaErr);
          pegmanPosition = snappedPos;
        }
        return pegmanPosition;
      } catch (error) {
        console.error("Error updating Pegman:", error);
        return pegmanPosition;
      }
    }
    async function ensureStreetView(lat, lng) {
      try {
        const apiKey = "<%= googleMapsApiKey %>"; // 必ず有効なGoogle Maps APIキー
        const url = `https://maps.googleapis.com/maps/api/streetview/metadata?location=${lat},${lng}&key=${apiKey}`;
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error("StreetView metadata fetch error: " + resp.status);
        }
        const metadata = await resp.json();
        // status が "OK" なら利用可能
        if (metadata.status === "OK") {
          console.log("StreetView available at:", lat, lng);
          // StreetViewをその座標にセット
          streetView.setPosition({ lat, lng });
        } else {
          console.warn("StreetView not available (status:", metadata.status, ")");
          // 代わりに別の処理 (フォールバック)：
          // 例: 近くの既知の座標に移動するとか、以前の座標を使う等
        }
      } catch (err) {
        console.error("Error in ensureStreetView:", err);
      }
    }
    // データの定期更新
    async function fetchData() {
  try {
    const response = await fetch("/api/sensorvalue");
    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    const data = await response.json();

    if (data && data.length > 0) {
      const latestData = data[0];
      currentValue = latestData.value;
      outputRpm = currentValue;
      currentLat = latestData.lat;
      currentLng = latestData.lng;
      updateCount = latestData.updateCount;
      totalDistance = latestData.totalDistance;

      const newPosition = { lat: currentLat, lng: currentLng };
      map.setCenter(newPosition);
      marker.position = newPosition;

      document.getElementById("current-log").textContent =
        `RPM: ${ outputRpm } 走行距離: ${ (totalDistance / 100).toFixed(2) } m`;

      // Pegman更新
      const newPegmanPos = await updatePegman(newPosition);
      
      // ★ ここで ensureStreetView を呼ぶ（新しいPegman座標が確定した後）
      await ensureStreetView(newPegmanPos.lat, newPegmanPos.lng);
    }
  } catch (error) {
    console.error("Error fetching sensor data:", error);
  }
}

    // 入力履歴の更新
    async function updateInputLog() {
      try {
        const response = await fetch("/api/haikuplace");
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const entries = await response.json();

        const inputLog = document.getElementById("input-log");
        inputLog.innerHTML = entries
          .map((entry) => {
            const displayPlace = entry.placename || "場所不明";
            // クリックでマップを開く。lat,lng を利用してリンク作成
            // 例: https://www.google.com/maps/search/?api=1&query=lat,lng
            const linkUrl = `https://www.google.com/maps/search/?api=1&query=${entry.lat},${entry.lng}`;

            return `
              <div class="log-entry" style="margin-bottom: 15px; padding: 10px; background: rgba(255, 255, 255, 0.8); border-radius: 5px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                <div style="font-size: 0.8em; color: #999; margin-bottom: 5px;">
                  ${new Date(entry.timestamp).toLocaleString()}
                </div>
                <div style="margin-bottom: 5px; font-size: 1em;">
                  ${entry.comment}
                </div>
                <div style="font-size: 0.8em; color: #999;">
                  <a href="${linkUrl}" target="_blank">${displayPlace}</a>
                </div>
              </div>
            `;
          })
          .join("");
      } catch (error) {
        console.error("Error updating input log:", error);
      }
    }
    // 定期的なデータ更新
    setInterval(fetchData, 1000);
    setInterval(updateInputLog, 10000);

    // 初期化
    window.onload = () => {
      initMap();
      fetchData();
      updateInputLog();
    };

    // リサイズ対応
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>

</html>
